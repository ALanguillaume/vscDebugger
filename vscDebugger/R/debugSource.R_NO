# used in example:
print(1)
print(2)
print(3)


main <- function(){
    # contains an example use of debugSource():
    line <- 2
    debugSource('debugSource.R', 3)
}


debugSource <- function(fileName, lines=c()){
    # parse file:
    body <- parse(fileName)

    # find steps/expressions corresponding to the requested lines
    ats <- lapply(lines, function(l,b) findLine(b,l), body)

    # iteratively set breakpoints
    for(at in ats){
        body <- mySetBreakpoint(body, at, finalize=FALSE)
    }
    
    # enclose entire body in {}
    body <- mySetBreakpoint(body, c(), finalize=TRUE)

    # eval body
    eval(body)
}


mySetBreakpoint <- function(b, at, finalize=TRUE){
    if(length(at)==0){
        # do nothing
    } else if(length(at)==1){
        # innermost step: replace expression expr with {browser(), expr}
        b[[at]] <- call('{', quote(browser()), b[[at]])
    } else{
        # outer steps: continue recursively
        b[[at[1]]] <- mySetBreakpoint(b[[at[1]]], at[-1])
    }

    if(finalize){
        # below is a complicated way of turning this:
        #     doStuff(1)
        #     ...
        #     doStuff(2)
        # into this:
        #     {
        #         doStuff(1)
        #         ...
        #         doStuff(2)
        #     }
        #
        b <- as.call(append(as.list(call('{')), b))
        # necessary to enable correct browser()-behaviour
    }

    return(b)
}

findLine <- function(b, line, at=c()){
    if(hasSrcref(b)){
        at <- findLineWithSrcref(b, line, at)
    } else{
        at <- findLineWithoutSrcref(b, line, at)
    }
    return(at)
}

findLineWithoutSrcref <- function(b, line, at){
    try({
        # fails if b is a symbol -> try()
        for(i in seq(length(b))){
            # try all sub-steps of b
            bb <- b[[i]]
            if(length(bb)>1){
                # assumption: only calls to '{' have sourceref -> length>1

                # (provisionally) append step to at
                at2 <- c(at, i)
                
                # continue search
                at3 <- findLine(bb, line, at2)

                # if length increased, the line was found down the parse-tree
                if(length(at3)>length(at2)){
                    at <- at3
                    break
                }
            }
        }
    }, silent=TRUE)
    return(at)
}

findLineWithSrcref <- function(b, line, at){
    # get source info about each step
    sr <- attr(b, 'srcref')

    # get interval of lines covered by each step
    mms <- lapply(sr, getMinLineMaxLine)

    # find the step/interval that contains the requested line
    ind <- findInterval(mms, line)

    if(ind==0){
        # not found
        return(at)
    } else{
        # get the content of the corresponding step (might be a long block itself)
        bb <- b[[ind]]

        # add index of step to at
        at <- c(at, ind)

        # continue search
        at <- findLine(bb, line, at)
        return(at)
    }
}


getMinLineMaxLine <- function(sr){
    # srcref is a list of integers containing info about minLine, maxLine, minCol, maxCol, ...Byte 
    # simply select the entries corresponding to minLine, maxLine:
    sr[c(1,3)]
}

findInterval <- function(mms, line){
    # checks only lines -> improve by also allowing breakpoint location by col?
    # only accepts precise hits -> return 'closest' hit to auto-correct bps?
    hits <- sapply(mms, intervalContains, line)
    ind <- which(hits)[1]
    if(is.na(ind)){
        return(0)
    } else{
        return(ind)
    }
}

intervalContains <- function(interval, x){
    return(x>=interval[1] && x<= interval[2])
}

hasSrcref <- function(x){
    'srcref' %in% names(attributes(x))
}
